1/2+1/2
1+1/8
4/1.125
16/8
8*8
64/8
64/8
8/8+1/8
(64+8)/64
64+8
72/64
4/(1+1/8)
1/10
1/8
1/15
1/6
1/12
1/6+1/12
(1/6)+(1/12)
1/4
1/2+1/4
1/3*2
1/(3*2)
(1/10+1/8+1/15+1/6+1/12)
4/0.5416667
6*12
18/72
72/9
sqrt(mean(c(300²,280²,270²,260²))
sqrt(mean(c(300²,280²,270²,260²)))
sqrt(mean(c(300^2,280^2,270^2,260^2)))
mean(c(300^2,280^2,270^2,260^2)))
mean(c(300^2,280^2,270^2,260^2))
sqrt(77225)
mean(c(200^2,350^2,300^2,400^2,450^2))
sqrt(mean(c(200^2,350^2,300^2,400^2,450^2)))
(12-10)/3
3*sqrt(1/30+1/30)
2/0.77
2/0.7745967
power.t.test(n = 30, sd = 3, delta = 2)
2*sqrt(30)
2*sqrt(2/30)
2/(2*sqrt(2/30))
2/(3*sqrt(2/30))
(3*sqrt(2/30))
qt(p = 0.05, df = 58, lower.tail = FALSE)
qt(p = 0.025, df = 58, lower.tail = FALSE)
qt(p = 0.025, df = 58, lower.tail = TRUE)
# Charger la bibliothèque ggplot2 pour la visualisation
library(ggplot2)
# Paramètres de l'expérience
mu1 <- 10
mu2 <- 12
s <- 3
n <- 30
alpha <- 0.05
df <- 2 * n - 2
diff <- mu2 - mu1
std_error <- s * sqrt(2 / n)
# Calculs pour les scores t
t_alpha <- qt(1 - alpha / 2, df)
t_effect <- diff / std_error
# Création de la grille de valeurs t pour les graphiques
t_values <- seq(-4, 4, length.out = 400)
# Densités pour les deux distributions
density_null <- dt(t_values, df)
density_effect <- dt(t_values - t_effect, df)
# Création du data frame pour ggplot
data <- data.frame(t_values, density_null, density_effect)
# Graphique avec ggplot
ggplot(data, aes(x = t_values)) +
geom_line(aes(y = density_null), color = "blue") +
geom_line(aes(y = density_effect), color = "red") +
geom_area(aes(y = density_null), fill = "blue", alpha = 0.2, xlim = c(t_alpha, Inf)) +
geom_area(aes(y = density_null), fill = "blue", alpha = 0.2, xlim = c(-Inf, -t_alpha)) +
geom_area(aes(y = density_effect), fill = "red", alpha = 0.2, xlim = c(-t_alpha, t_alpha)) +
geom_vline(xintercept = t_alpha, linetype = "dashed", color = "black") +
geom_vline(xintercept = t_effect, linetype = "dashed", color = "green") +
labs(title = "Distribution t de Student sous H0 et H1",
x = "Valeurs de t", y = "Densité de probabilité") +
theme_minimal()
pt(q = -0.58, df = 58, lower.tail = TRUE)
1-0.2820805
pt(q = 2, df = 58, lower.tail = TRUE)
power.t.test(delta = 2, sd = 3, power = 0.8)
2*17.47
(1.96+0.84/0.67)^2
2*(1.96+0.84/0.67)^2
1.96+0.84
2*(1.96+0.84/(0.67))^2
2*((1.96+0.84)/(0.67))^2
((1.96+0.84)/(0.67))^2
2*17.46491
n_each_group = (2 * 3**2 * (1.96 + 0.84)**2) / (0.67**2)
n_each_group = (2 * 3^2 * (1.96 + 0.84)^2) / (0.67^2)
n_each_group = (2  * (1.96 + 0.84)^2) / (0.67^2)
2*(1.96+0.84)^2/2^2
power.t.test(delta = 4, sd = 2)
power.t.test(delta = 4, sd = 2, power = 0.8)
2*sqrt(2/4)
qt(0.025, 6, lower.tail = FALSE)
2.447-2.823
pt(-0.376, df = 6)
1-0.359
power.t.test(n = 4, delta = 4, sd = 2)
4/.414
4/1.414
pt(-0.381, df = 6)
1-0.358
power.prop.test(n = 150, p1 = 0.70, p2 = 0.85)
sqrt(70*(1-70)/150 + 85*(1-85)/150)
sqrt((70*(1-70))/150 + (85*(1-85))/150)
sqrt(((70*(1-70))/150) + ((85*(1-85))/150))
(70*(1-70))
(70*(1-70))/(150)
(85*(1-85))/(150)
sqrt(-32.2-47.6)
(85*(1-85))/(150)
abs((85*(1-85))/(150))
sqrt(32.2+47.6)
(0.85*(1-0.85))/(150)
sqrt(((0.70*(1-0.70))/150) + ((0.85*(1-0.85))/150))
0.15/0.047
3.162-1.960
pnorm(-1.202)
1 - pnorm(-1.202)
power.prop.test(n = 150, p1 = 0.70, p2 = 0.85)
power.prop.test( p1 = 0.60, p2 = 0.75)
power.prop.test( p1 = 0.60, p2 = 0.75, power = 0.80)
3.3524/0.0225
(1.96+0.84)^2
1.96^2+0.84^2
7.84*(0.60*0.40+0.75*0.25)
0.15^2
3.3516/0.025
3.3516/0.0225
3.3524/0.0225
qnorm(0.90)
sqrt(((0.40*(1-0.40))/100) + ((0.55*(1-0.55))/100))
qnorm(0.05)
qnorm(0.05, lower.tail = TRUE)
qnorm(0.025, lower.tail = TRUE)
qnorm(0.025, lower.tail = FALSE)
pt(-0.58, 58)
0.15/0.0698
1.96-2.148
pnorm(-0.188, lower.tail = FALSE)
pnorm(-0.188)
1-0.4254383
3.841-0.8
library(pwr)
power.prop.test(n = 10, p1 = 40, p2 = 55)
power.prop.test(n = 100, p1 = 40, p2 = 55)
power.prop.test(n = 100, p1 = 0.40, p2 = 0.55)
power.prop.test(n = 10, p1 = 0.40, p2 = 0.55)
install.packages("pwr")
pwr::pwr.chisq.test(w = 0.15, N = 20, df = 1)
pwr::pwr.chisq.test(w = 0.15, N = 10, df = 1)
qchisq(0.95, df = 1)
# Création du tableau de contingence
observed <- matrix(c(4, 6, 6, 4), nrow = 2, byrow = TRUE)
# Nommer les dimensions pour la clarté
dimnames(observed) <- list(supplement = c("A", "B"),
outcome = c("Success", "Failure"))
# Effectuer le test du chi-carré
test_result <- chisq.test(observed, correct = FALSE)  # 'correct = FALSE' pour désactiver la correction de Yates
# Afficher les résultats
print(test_result)
library(pwr)
# Exemple de calcul de puissance pour un test du chi-carré
effect_size <- ES.w1(w1 = observed[1,1]/sum(observed[1,]), w2 = observed[2,1]/sum(observed[2,]))
# Exemple de calcul de puissance pour un test du chi-carré
effect_size <- ES.w1(P0 = observed[1,1]/sum(observed[1,]), P1 = observed[2,1]/sum(observed[2,]))
power_analysis <- pwr.chisq.test(w = effect_size, N = sum(observed), df = 1, sig.level = 0.05)
# Afficher l'analyse de puissance
print(power_analysis)
# Pour le test du chi-carré
chi2_value <- test_result$statistic
p_value <- test_result$p.value
chi2_critical <- qchisq(0.95, df = 1)  # Obtention de la valeur critique
# Pour l'analyse de puissance
calculated_power <- power_analysis$power
3.84-0.8
pchisq(3.04, df = 1)
1 - pchisq(3.04, df = 1)
1 - pchisq(3.04, df = 1, lower.tail = FALSE)
(6.5+7)/2
Sys.getenv("GITHUB_PAT")
vec <- rnorm(100, 10, 2)
vec1 <- rnorm(100, 10, 2)
vec2 <- rnorm(100, 10, 2)
library(ggplot2)
ggplot(vec1, aes(x)) + geom_line()
ggplot(as.data.frame(vec1), aes(x)) + geom_line()
ggplot(as.data.frame(vec1) + geom_line()
ggplot(as.data.frame(vec1)) + geom_line()
as.data.frame(vec1)
ggplot(data = as.data.frame(vec1)) + geom_line()
ggplot(data = as.data.frame(vec1), aes(x = vec1)) + geom_line()
ggplot(data = as.data.frame(vec1), aes(y = vec1)) + geom_line()
ggplot(data = as.data.frame(vec1), aes(y = vec1, x = 1:100) ) + geom_line()
ggplot(data = as.data.frame(vec1), aes(y = order(vec1), x = 1:100) ) + geom_line()
order(vec1)
sort(vec1)
ggplot(data = as.data.frame(vec1), aes(y = sort(vec1), x = 1:100) ) + geom_line()
ggplot(data = as.data.frame(vec1), aes(y = sort(vec2), x = 1:100) ) + geom_line()
data <- data.frame(vec1 = vec1, vec2 = vec2)
data <- data.frame(values = c(vec1,vec2), label = c(rep("vec1"),rep("vec2")))
View(data)
data <- data.frame(values = c(vec1,vec2), label = c(rep("vec1",100),rep("vec2",100)))
View(data)
data <- data.frame(values = c(vec1,vec2), label = factor(c(rep("vec1",100),rep("vec2",100))))
View(data)
ggplot(data = data, aes(y = sort(vec1)) + geom_boxplot()
ggplot(data = data, aes(y = sort(vec1)) + geom_boxplot())
ggplot(data = data) + geom_boxplot()
ggplot(data = data, aes(y = values)) + geom_boxplot()
ggplot(data = data, aes(label, values)) + geom_boxplot()
t.test(vec1, vec2)
t.test(vec1, vec2)
t.test(vec1, vec2)
t.test(vec1, vec2)
mean(vec)
mean(vec)
mean(vec1)
mean(vec2)
sd(vec1)
sd(vec2)
# Installer et charger le package ggplot2 pour les graphiques
if (!require(ggplot2)) install.packages("ggplot2", dependencies=TRUE)
library(ggplot2)
# Données simulées
x <- 1:10
y_add <- 2 * x + 5  # Relation additive
y_mult <- 3 * 1.5^x  # Relation multiplicative
# Création d'un data frame pour les graphiques
data_add <- data.frame(x = x, y = y_add)
data_mult <- data.frame(x = x, y = y_mult)
# Graphique linéaire pour la relation additive
p_add <- ggplot(data_add, aes(x, y)) +
geom_line(color = 'blue') +
ggtitle("Graphique linéaire: Relation additive") +
xlab("x") + ylab("y")
# Graphique semi-logarithmique pour la relation multiplicative
p_mult <- ggplot(data_mult, aes(x, log(y))) +
geom_line(color = 'red') +
ggtitle("Graphique semi-logarithmique: Relation multiplicative") +
xlab("x") + ylab("log(y)")
p_add
p_mult
p_mult <- ggplot(data_mult, aes(x, y)) +
geom_line(color = 'red') +
ggtitle("Graphique semi-logarithmique: Relation multiplicative") +
xlab("x") + ylab("y")
p_mult
# Installer et charger le package ggplot2 pour les graphiques
if (!require(ggplot2)) install.packages("ggplot2", dependencies=TRUE)
library(ggplot2)
# Données simulées
x <- 1:10
y_add <- 2 * x + 5 + rnorm(n = 100, mean = 0, sd = 20)  # Relation additive
y_mult <- 3 * 1.5^x  # Relation multiplicative
# Création d'un data frame pour les graphiques
data_add <- data.frame(x = x, y = y_add)
data_mult <- data.frame(x = x, y = y_mult)
# Graphique linéaire pour la relation additive
p_add <- ggplot(data_add, aes(x, y)) +
geom_line(color = 'blue') +
ggtitle("Graphique linéaire: Relation additive") +
xlab("x") + ylab("y")
# Graphique semi-logarithmique pour la relation multiplicative
p_mult <- ggplot(data_mult, aes(x, y)) +
geom_line(color = 'red') +
ggtitle("Graphique semi-logarithmique: Relation multiplicative") +
xlab("x") + ylab("y")
# Affichage des graphiques
print(p_add)
print(p_mult)
p_add
p_add <- ggplot(data_add, aes(x, y)) +
geom_point(color = 'blue') +
ggtitle("Graphique linéaire: Relation additive") +
xlab("x") + ylab("y")
p_add
p_add <- ggplot(data_add, aes(x, y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +  # Ajout d'une ligne de régression
ggtitle("Graphique de dispersion avec ajustement linéaire") +
xlab("Variable indépendante (x)") +
ylab("Variable dépendante (y)")
p_add
# Données simulées
x <- 1:10
y_add <- 2 * x + 5 + rnorm(n = 100, mean = 0, sd = 2)  # Relation additive
y_mult <- 3 * 1.5^x  # Relation multiplicative
# Création d'un data frame pour les graphiques
data_add <- data.frame(x = x, y = y_add)
data_mult <- data.frame(x = x, y = y_mult)
# Graphique linéaire pour la relation additive
p_add <- ggplot(data_add, aes(x, y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +  # Ajout d'une ligne de régression
ggtitle("Graphique de dispersion avec ajustement linéaire") +
xlab("Variable indépendante (x)") +
ylab("Variable dépendante (y)")
p_add
x <- 1:100
y <- 50 + 2 * x + rnorm(100, mean = 0, sd = 20)  # Relation additive
y_mult <- 3 * 1.5^x  # Relation multiplicative
# Création d'un data frame pour les graphiques
data_add <- data.frame(x = x, y = y_add)
data_mult <- data.frame(x = x, y = y_mult)
# Graphique linéaire pour la relation additive
p_add <- ggplot(data_add, aes(x, y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +  # Ajout d'une ligne de régression
ggtitle("Graphique de dispersion avec ajustement linéaire") +
xlab("Variable indépendante (x)") +
ylab("Variable dépendante (y)")
p_add
x <- 1:100
y <- 50 + 2 * x + rnorm(100, mean = 0, sd = 2)  # Relation additive
y_mult <- 3 * 1.5^x  # Relation multiplicative
# Création d'un data frame pour les graphiques
data_add <- data.frame(x = x, y = y_add)
data_mult <- data.frame(x = x, y = y_mult)
# Graphique linéaire pour la relation additive
p_add <- ggplot(data_add, aes(x, y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +  # Ajout d'une ligne de régression
ggtitle("Graphique de dispersion avec ajustement linéaire") +
xlab("Variable indépendante (x)") +
ylab("Variable dépendante (y)")
p_add
x <- 1:100
y <- 50 + 2 * x + rnorm(100, mean = 0, sd = 2)  # Relation additive
y_mult <- 3 * 1.5^x  # Relation multiplicative
# Création d'un data frame pour les graphiques
data_add <- data.frame(x = x, y = y_add)
data_mult <- data.frame(x = x, y = y_mult)
# Graphique linéaire pour la relation additive
p_add <- ggplot(data_add, aes(x, y)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "blue") +  # Ajout d'une ligne de régression
ggtitle("Graphique de dispersion avec ajustement linéaire") +
xlab("Variable indépendante (x)") +
ylab("Variable dépendante (y)")
p_add
# Installer et charger le package ggplot2 pour les graphiques
if (!require(ggplot2)) install.packages("ggplot2", dependencies=TRUE)
library(ggplot2)
# Données simulées
x <- 1:50
y <- 5 + 2 * x  # Chaque valeur augmente de 2 par rapport à la précédente
# Création d'un data frame pour le graphique
data <- data.frame(x = x, y = y)
# Graphique de dispersion avec une ligne
p <- ggplot(data, aes(x, y)) +
geom_point() +  # Points de données
geom_line(color = "blue") +  # Ligne montrant la relation additive
ggtitle("Relation Additive Claires Sans Bruit") +
xlab("X (Temps ou Ordre Séquentiel)") +
ylab("Y (Valeur Mesurée)")
# Affichage du graphique
print(p)
# Installer et charger le package ggplot2 pour les graphiques
if (!require(ggplot2)) install.packages("ggplot2", dependencies=TRUE)
library(ggplot2)
# Données simulées avec du bruit
set.seed(123)  # Pour la reproductibilité
x <- 1:50
y <- 5 + 2 * x + rnorm(50, mean = 0, sd = 5)  # Augmentation additive de 2 avec du bruit
# Création d'un data frame pour le graphique
data <- data.frame(x = x, y = y)
# Graphique de dispersion avec une ligne
p <- ggplot(data, aes(x, y)) +
geom_point() +  # Points de données
geom_line(color = "blue") +  # Ligne montrant la relation
geom_smooth(method = "lm", se = TRUE, color = "red", linetype = "dashed") +
ggtitle("Relation Additive avec Bruit") +
xlab("X (Temps ou Ordre Séquentiel)") +
ylab("Y (Valeur Mesurée)")
# Affichage du graphique
print(p)
# Installer et charger le package ggplot2 pour les graphiques
if (!require(ggplot2)) install.packages("ggplot2", dependencies=TRUE)
library(ggplot2)
# Données simulées avec du bruit pour une échelle multiplicative
set.seed(123)  # Pour la reproductibilité
x <- 1:50
base_value <- 5
multiplier <- 1.1
noise <- rnorm(50, mean = 0, sd = 0.5)  # Bruit normalement distribué
y <- base_value * multiplier^x * exp(noise)  # Multiplication par exp(noise) pour ajouter le bruit de façon multiplicative
# Création d'un data frame pour le graphique
data <- data.frame(x = x, y = y)
# Graphique de dispersion avec une ligne
p <- ggplot(data, aes(x, y)) +
geom_point() +  # Points de données
geom_line(color = "blue") +  # Ligne montrant la relation
geom_smooth(method = "lm", se = TRUE, formula = y ~ poly(x, 2), color = "red", linetype = "dashed") +
scale_y_log10() +  # Échelle logarithmique pour y
ggtitle("Relation Multiplicative avec Bruit") +
xlab("X (Temps ou Ordre Séquentiel)") +
ylab("Y (Valeur Mesurée)")
# Affichage du graphique
print(p)
# Données simulées avec du bruit pour une échelle multiplicative
set.seed(123)  # Pour la reproductibilité
x <- 1:50
base_value <- 5
multiplier <- 1.1
noise <- rnorm(50, mean = 0, sd = 0.5)  # Bruit normalement distribué
y <- base_value * multiplier^x * exp(noise)  # Multiplication par exp(noise) pour ajouter le bruit de façon multiplicative
# Création d'un data frame pour le graphique
data <- data.frame(x = x, y = y)
# Graphique de dispersion avec échelle logarithmique pour y
p <- ggplot(data, aes(x, y)) +
geom_point() +  # Points de données
geom_line(color = "blue") +  # Ligne montrant la relation
geom_smooth(method = "lm", se = TRUE, formula = y ~ x, color = "red", linetype = "dashed") +
scale_y_log10() +  # Échelle logarithmique pour y
ggtitle("Relation Multiplicative avec Bruit (Échelle Semi-logarithmique)") +
xlab("X (Temps ou Ordre Séquentiel)") +
ylab("Y (Valeur Mesurée sur Échelle Logarithmique)")
# Affichage du graphique
print(p)
# Installer et charger le package ggplot2 pour les graphiques
if (!require(ggplot2)) install.packages("ggplot2", dependencies=TRUE)
library(ggplot2)
# Données simulées avec du bruit pour une échelle multiplicative
set.seed(123)  # Pour la reproductibilité
x <- 1:50
base_value <- 5
multiplier <- 1.1
noise <- rnorm(50, mean = 0, sd = 0.5)  # Bruit normalement distribué
y <- base_value * multiplier^x * exp(noise)  # Multiplication par exp(noise) pour ajouter le bruit de façon multiplicative
# Création d'un data frame pour le graphique
data <- data.frame(x = x, y = y)
# Graphique de dispersion
p <- ggplot(data, aes(x, y)) +
geom_point() +  # Points de données
geom_line(color = "blue") +  # Ligne reliant les points pour montrer la croissance
geom_smooth(method = "nls", formula = y ~ a * exp(b * x), method.args = list(start = list(a = 5, b = log(1.1))), se = FALSE, color = "red") +
ggtitle("Courbe Exponentielle avec Bruit") +
xlab("X (Temps ou Ordre Séquentiel)") +
ylab("Y (Valeur Mesurée)")
p
2*-2
(2*-2)^1/2
(2*2)^1/2
(2*2*4)^1/2
(2*2*-4)^1/2
(2*2*-4*-2)^1/2
(2*2*4*2)^1/2
(2*2*4*2)^1/4
(2*2*4*-2)^1/4
(2+2+4+2)/4
4/mean(c(2,4,4,8))
4/1/mean(c(2,4,4,8))
4/1/(mean(c(2,4,4,8)))
mean(c(2,4,4,8)))/4
mean(c(2,4,4,8))/4
psych::harmonic.mean(2,4,4,8)
psych::harmonic.mean(c(2,4,4,8))
mean(c(200,300,350,400,450))
mean(c(250,300,280,270,260))
3*sqrt(2/30)
3*sqrt(2/60)
t_values <- seq(-4, 4, length.out = 400)
dt(t_values, 58)
density_null <- dt(t_values, df)
density_null <- dt(t_values, 58)
mean(density_null)
density_effect <- dt(t_values - t_effect, df)
density_effect <- dt(t_values - 2.58, 58)
density_effect
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(
fig.width=9, fig.height=3.5, fig.retina=3,
out.width = "100%",
cache = FALSE,
echo = TRUE,
message = FALSE,
warning = FALSE,
hiline = TRUE
)
library(ggplot2)
# Paramètres de l'expérience
mu1 <- 10
mu2 <- 12
s <- 3
n <- 30
alpha <- 0.05
df <- 2 * n - 2
diff <- mu2 - mu1
std_error <- s * sqrt(2 / n)
# Calculs pour les scores t
t_alpha <- qt(1 - alpha / 2, df)
t_effect <- diff / std_error
# Création de la grille de valeurs t pour les graphiques
t_values <- seq(-4, 4, length.out = 400)
# Densités pour les deux distributions
density_null <- dt(t_values, df)
density_effect <- dt(t_values - t_effect, df)
# Création du data frame pour ggplot
data <- data.frame(t_values, density_null, density_effect)
data
ggplot(data, aes(x = t_values)) +
geom_line(aes(y = density_null), color = "blue") +
geom_line(aes(y = density_effect), color = "red")
